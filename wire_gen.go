// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"github.com/Mirai3103/Project-Re-ENE/agent"
	"github.com/Mirai3103/Project-Re-ENE/asr"
	"github.com/Mirai3103/Project-Re-ENE/config"
	"github.com/Mirai3103/Project-Re-ENE/embedding"
	"github.com/Mirai3103/Project-Re-ENE/llm"
	"github.com/Mirai3103/Project-Re-ENE/package/audio"
	"github.com/Mirai3103/Project-Re-ENE/services"
	"github.com/Mirai3103/Project-Re-ENE/store"
	"github.com/Mirai3103/Project-Re-ENE/tts"
	"github.com/firebase/genkit/go/ai"
	"github.com/firebase/genkit/go/genkit"
	"github.com/lmittmann/tint"
	"log/slog"
	"os"
)

import (
	_ "embed"
)

// Injectors from wire.go:

// InitializeApplication wires up all dependencies
func InitializeApplication(ctx context.Context, cfg *config.Config) (*Application, error) {
	logger := ProvideLogger()
	recorder, err := ProvideAudioRecorder(cfg)
	if err != nil {
		return nil, err
	}
	genkit, err := ProvideLLMModel(ctx, cfg)
	if err != nil {
		return nil, err
	}
	modelArg, err := ProvideLLMModelArg(ctx, cfg)
	if err != nil {
		return nil, err
	}
	model, err := embedding.New(ctx, cfg)
	if err != nil {
		return nil, err
	}
	db, err := store.NewSQLiteDB()
	if err != nil {
		return nil, err
	}
	queries := store.New(db)
	embeddingService := agent.NewEmbeddingService(cfg, logger, model, queries)
	ttsAgent, err := tts.New(cfg, logger)
	if err != nil {
		return nil, err
	}
	asrAgent, err := asr.New(cfg, logger)
	if err != nil {
		return nil, err
	}
	agentConfig := ProvideAgentConfig(cfg)
	agentAgent := agent.NewAgent(genkit, modelArg, embeddingService, ttsAgent, asrAgent, queries, agentConfig, logger)
	appService := services.NewAppService(cfg, logger, recorder, agentAgent)
	modelService := services.NewModelService(cfg, logger)
	recorderService := services.NewRecorderService(cfg, recorder)
	configService := services.NewConfigService(cfg, logger)
	chatService := services.NewChatService(cfg, logger, queries)
	application := &Application{
		AppService:       appService,
		ModelService:     modelService,
		RecorderService:  recorderService,
		ConfigService:    configService,
		ChatService:      chatService,
		Agent:            agentAgent,
		EmbeddingService: embeddingService,
	}
	return application, nil
}

// wire.go:

// ProvideLogger creates a new logger instance
func ProvideLogger() *slog.Logger {
	w := os.Stderr
	return slog.New(tint.NewHandler(w, nil))
}

// ProvideAudioRecorder creates a new audio recorder
func ProvideAudioRecorder(cfg *config.Config) (audio.Recorder, error) {
	return audio.NewFFmpegRecorder(audio.RecorderConfig{
		Channels:    1,
		SampleRate:  44100,
		InputDevice: cfg.ASRConfig.InputDevice,
	})
}

// ProvideLLMModel wraps the llm.New function
func ProvideLLMModel(ctx context.Context, cfg *config.Config) (*genkit.Genkit, error) {
	model, _, err := llm.New(ctx, cfg)
	return model, err
}

// ProvideLLMModelArg provides the model argument
func ProvideLLMModelArg(ctx context.Context, cfg *config.Config) (ai.ModelArg, error) {
	_, modelArg, err := llm.New(ctx, cfg)
	return modelArg, err
}

// ProvideAgentConfig extracts agent config from main config
func ProvideAgentConfig(cfg *config.Config) *config.AgentConfig {
	return &cfg.AgentConfig
}

// Application holds all initialized services
type Application struct {
	AppService       *services.AppService
	ModelService     *services.ModelService
	RecorderService  *services.RecorderService
	ConfigService    *services.ConfigService
	ChatService      *services.ChatService
	Agent            *agent.Agent
	EmbeddingService *agent.EmbeddingService
}
